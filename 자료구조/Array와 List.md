## 1. Array
### 1)정의 
- 인덱스를 가진 데이터의 집합
- 같은 데이터 타입의 변수들로 이루어진 자료구조
- 참조 객체이므로 배열을 가리키는 참조 변수는 스택 영역에서 할당, 주소값은 힙 영역에서 생성되는 배열의 주소값을 의미

### 2) 특징
- 배열 크기가 고정적
- 메모리 공간을 연속적으로 구성
- 참조를 위한 추가 메모리 할당이 필요 없음

### 3) 장단점
* 장점 : access 타임이 짧다(random access) , 특정 인덱스의 원소값을 수정하는 시간 역시 짧다. ( 둘 다 O(1)의 시간복잡도를 가짐 )
* 단점 : 삽입/삭제 시 뒤에 요소들을 이동해야 해서 시간이 오래 걸린다.

### 4) 추가 설명
- array는 ram, 혹은 박스 공간들이라고 생각할 수 있습니다. 컴퓨터는 사용자가 array를 생성할 때 "얼마나 긴 메모리"를 만들 것인지 입력받습니다. 컴퓨터는 이 배열이 "어디서부터 시작하는지,
", "배열이 얼마나 긴지"를 알기 때문에 각 인덱스의 주소값을 가지고 임의의 데이터 위치를 한번에, 빠르게 접근할 수가 있습니다. (random access)
- 반면, 특정 값을 찾기 위해선 각 박스의 값을 하나 하나 확인해야 합니다. 주소가 있기 때문에 접근은 빠르지만, 해당 위치 값들은 직접 순차적으로 확인해야 합니다.(linear search)
마찬 가지로 값을 추가/삭제할 때 임의의 인덱스에 값을 추가하면, 나머지 인덱스(인덱스 값이 더 큰 대상)들은 인덱스가 한 칸씩 뒤로 밀리도록 값을 수정해야 합니다. 반대로 데이터를 삭제하면 한 칸씩 앞으로 당깁니다.
- 따라서 배열은 데이터를 접근하는 건 빠르지만, 검색,추가,삭제할 때 느려지므로 배열에서 추가, 삭제하려면 맨 끝에서 작업하는 걸 추천합니다.



## 2.List
### 1) 정의
- 인덱스 없이 순서가 있는 데이터들의 집합

### 2) 특징
- 메모리에 분산되어 저장 가능(array와 차이)
- 데이터의 중복 허용(set과 차이)
- 저장 공간 크기가 가변적이며, 중간에 빈 공간을 허용하지 않음(array와 차이)

### 4) 장단점
* 장점 : 특정 데이터의 삽입/삭제가 빠름, 메모리의 재사용성이 편리
* 단점 : 참조를 위한 메모리가 필요함
 특정 위치 접근 시 맨 처음 노드부터 순차적으로 탐색해야 하기 때문에 접근 속도가 느리다.
* 순차성을 보장하지 못하기 때문에 spacial locality 보장이 되지 않아 cash hit가 어렵다.
* cf) spacial locality : 프로그램 실행 시 접근하는 메모리 영역은 이미 접근이 이루어진 영역의 근처일 확률이 높다는 프로그램 성격 표현

### 5) 추가 설명
리스트의 핵심은 엘리먼트들 간의 순서입니다.( 리스트를 다른 말로는 시퀀스(sequence) 라고도 부르기도 함) 즉, 순서가 있는 데이터의 모임이 리스트이며
Array에서의 인덱스는 값에 대한 유일무이한 식별자를 의미하는 반면, 리스트에서 인덱스는 몇 번째 데이터인가 정도의 의미를 가집니다. 

### 6) 자바에서의 List
- 자바의 collection framework의 인터페이스 중 하나
* cf) collection framework: 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
- 자바는 LinkedList / ArrayList라는 2가지 형태의 리스트를 지원



## 3. ArrayList
### 1) 정의
![LinkedList,ArrayList구조차이](https://user-images.githubusercontent.com/48278519/140638866-68be5c7f-84f5-4b54-a4df-63a22f31363d.png)

- 내부적으로 Array를 사용하여 요소를 저장하는 구조.
- 배열의 "고정적 크기" 한계점을 극복하기 위해 탄생

### 2) 특징
- List 인터페이스의 메서드를 사용하면서 Array의 인덱스 개념 사용 가능
- 중간에 빈 공간을 허용하지 않음
- 내부적으로 배열을 사용하믈 물리공간과 논리공간이 동일 => 인덱스 연산자(get,Set)을 통해 인덱스에 쉽게 접근 가능
- 저장 리스트 생성 시 별도의 크기를 지정하거나 이후 크기를 관리할 필요가 없음
- 자바는 한 번 배열의 크기를 늘릴 때마다 **기존 배열 x 1.5배**  만큼 늘린다. 좀 더 정확히 말하면, 기존 용량의 1.5배를 늘린 새 배열에 기존 배열을 copy한다.
```java
    // arrayList의 새로운 용량을 정하는 함수
    private int newCapacity(int minCapacity) {
        int oldCapacity = this.elementData.length;
        // 기존 용량 + 기존 용량/2 
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity <= 0) {
            if (this.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // arrayList가 비어있을 때
                return Math.max(10, minCapacity);
            } else if (minCapacity < 0) {
                throw new OutOfMemoryError();
            } else {
                return minCapacity;
            }
        } else {
            // 새로운 용량이 기존 용량의 +1 된 사이즈보다 크면
            return newCapacity - 2147483639 <= 0 ? newCapacity : hugeCapacity(minCapacity);
        }
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) {
            throw new OutOfMemoryError();
        } else {
            return minCapacity > 2147483639 ? 2147483647 : 2147483639;
        }
    }
```

### 3) 장단점
* 장점 : get()메소드가 지원되므로, 특정 원소 접근하는데 시간 복잡도가 O(1)
         set()메서드가 지원되므로, 특정 원소 수정의 시간 복잡도 역시 O(1)
         기존 list의 장점과 동일하게 메모리 공간의 낭비가 없음
         
* 단점 : 원소 삽입/삭제 시간 복잡도는 O(n)
         add / remove 메서드가 수행될 때마다 저장 공간을 재할당 하므로, 맨 끝의 원소를 추가/삭제하는 시간복잡도 역시 O(n)이 걸림

### 4) 삽입 / 삭제 과정

#### 삽입 

![ArrayList삽입_1](https://user-images.githubusercontent.com/48278519/140638489-5c16855a-e971-40dc-a054-25836f44e9b8.png)

 ① 삭제할 자료가 위치한 인덱스의 자료를 삭제한다.
 
 ② 삭제한 자료의 인덱스를 기준으로 이후의 자료들을 이동하는 연산을 한다.
 
 ③ List의 맨 마지막은 비어있는 상태로 완료한다.
 
 #### 삭제
![ArrayList삭제_2](https://user-images.githubusercontent.com/48278519/140638731-03901c33-375a-4f5a-b26f-f7aab372d520.png)

① 삭제할 자료가 위치한 인덱스의 자료를 삭제한다.

② 삭제한 자료의 인덱스를 기준으로 이후의 자료들을 이동하는 연산을 한다.

③ List의 맨 마지막은 비어있는 상태로 완료한다.


## 4.LinkedList
### 1) 정의

![LinkedList](https://user-images.githubusercontent.com/48278519/140638914-0400c3b3-f8ca-49a9-ba73-01e8ee88258d.png)

- ArrayList의 한계(원소를 삽입 삭제시 시간 복잡도가 O(n))를 극복하기 위해 탄생했음
- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조

### 2) 특징
- 한 원소에서 값과 다음 원소의 주소를 알고 연결하는 방식
- 서로 주소를 연결하는 방식이기 때문에, 물리 공간과 논리 공간이 일치하지 않고 메모리 공간이 연속적으로 구성되어 있지 않음
- 따라서 인덱스 연산자는 활용할 수 없음 get/set 메서드는 사용 가능

### 3) 장단점
* 장점: 원소의 맨 처음 삽입/맨 마지막 삭제 시간 복잡도는 O(1) (이전 노드와 다음 노드가 참조하고 있는 노드의 링크만 변경해주면 되며, 새롭게 저장 공간을 확장하거나 축소하여 재할당 해줄 필요가 없으므로)
* 단점: 특정 지점을 접근하는 시간 복잡도는 O(n) ( 맨 처음 노드 혹은 맨 마지막 노드부터 찾고자 하는 위치를 향해 next 혹은 prev를 타고 가며 순차적으로 탐색해야 하므로)
        리스트 중간에 삽입/삭제 시간 복잡도는 O(n) (마찬가지로 삭입 삭제할 위치를 찾아가기 위해 순차적으로 탐색해야 하기 대문)
     
### 4) 삽입/삭제

#### 삽입
![LinkedList삽입](https://user-images.githubusercontent.com/48278519/140638759-79206101-06b1-40f9-afa6-d570ea562c3e.png)

① 추가될 자료의 node를 생성한다.

② 추가될 자료의 인덱스 이전 node와 추가될 자료 인덱스 이후 node를 설정한다.

#### 삭제
![LinkedLst삭제](https://user-images.githubusercontent.com/48278519/140638823-58bc3b58-5208-4d7c-870f-6148e3faf52a.png)

 ① 삭제할 노드의 이전 노드와 이후 노드를 연결한다.


## 6. 면접 질문 정리
### Array와 List의 차이는 무엇인가요?
- 배열은 인덱스를 가진 데이터의 집합이고, 리스트는 인덱스 없이 순차적으로 저장된 데이터의 집합입니다.
- 배열은 랜덤 엑세스를 통해 탐색 속도가 빠르지만, 데이터 삽입 삭제는 느립니다. 반면, 리스트는 랜덤 엑세스가 불가능하여 탐색 속도가 느리지만 데이터의 삽입/삭제가 빠릅니다.

### Array와 ArrayList의 차이는 무엇인가요?
- Array은 크기가 고정되어 있지만 ArrayList는 크기가 동적인 배열입니다.
- Array는 type와 object 모두 담을 수 있지만, ArrayList는 object만 담을 수 있습니다.
- Array는 element들을 할당하기 위해 assignment 연산자를 사용해야 하고, ArrayList는 add()메서드를 통해 삽입해야 합니다.

### ArrayList와 LinkedList의 차이를 설명할 수 있나요?
- ArrayList는 물리주소와 논리주소가 동일하며 메모리 공간이 연속적으로 구성되지만, LinkedList는 물리주소와 논리주소가 동일하지 않을 수 있으며 메모리 공간 또한 연속적으로 구성되지 않을 수 있습니다.
- ArrayList는 Index를 통해 특정 원소에 대한 랜덤 접근이 가능한 반면, LinkedList는 불연속적으로 위치한 각 요소들 간 주소를 연결하는 방식이기 때문에 특정 원소를 접근하기 위해선 순차 탐색을 해야 하므로 접근 시간이 느립니다.
- ArrayList는 데이터 삽입/삭제 시간이 느립니다.(삽입/삭제 후 기존 데이터들의 위치를 변경하고 삽입의 경우는 삽입 전 메모리 재할당을 해야하기 때문), 반면 LinkedList는 시작/끝 위치의 데이터 삽입/삭제가 빠릅니다.

### 데이터를 순차적으로 찾을때 가장 적합한 것은 무엇일까요?
- Array(List). 연속적인 메모리 공간으로 구성되기 때문에, 다음 인덱스 주소로 배열 요소에 빠르게 접근이 가능합니다. 
반면 LinkedList는 불연속적인 메모리 공간으로 구성되기 때문에 다음 데이터를 접근하기 위해서 다음 노드의 주소를 확인하면서 순차적으로 탐색하는 방식으로 오래걸릴 수 있습니다.  

### 데이터를 순차적으로 추가, 삭제할 때 가장 적합한 것은 무엇일까요?
- LinkedList. ArrayList는 순차적인 추가/삭제 시에도 저장 공간을 재할당 하므로 O(n)의 시간이 걸리지만 LinkedList는 가장 끝 노드를 삭제 후 이전 노드의 연결 정보만 수정하면 되므로 O(1)의 시간이 걸리기 떄문입니다.
 
### 데이터를 빈번하게 추가, 삭제할때 가장 적합한것은 무엇일까요? 
- 직전 답변과 동일( ArrayList는 매번 저장 공간을 재할당 하므로 오래 걸림 )
*) 만약 추가,삭제하려는 대상의 인덱스가 매우 크다면 ArrayList가 더 빠를 수도 있습니다.(해당 위치까지 접근하는데 오래 걸리기 때문)

### ArrayList나 List에서 중간에 데이터를 삽입하면 내부적으로 어떻게 동작하는지 아시나요?
-  추가할 자료의 노드를 생성한 후, 추가된 노드의 앞 노드의 연결 정보를 수정합니다.
-  추가될 위치의 이전 node의 다음 node를 새로 추가될 node로 설정하고, 추가될 node의 다음 node 정보는 추가되기 이전 node의 다음 node로 설정합니다.
   
### LinkedList는 이전 Node, 이후 Node의 정보를 어떻게 알까요?
- Node 구조체 안에 본인의 이전/이후 Node의 주소값을 저장합니다.

### ArrayList와 List 둘중에 검색속도는 어느것이 더 빠를까요?
- ArrayList. ( 직접 데이터 값을 확인하고 비교하는 건 둘이 비슷하겠지만 그 데이터까지 접근하는데 걸리는 시간이 더 빠름)


## * 결론
- 저장할 데이터의 개수가 정해져 있고 / 삽입, 삭제 작업이 적고 / 특정 위치의 데이터를 조회하는 작업이 많다면 Array
- 저장할 데이터의 개수가 미정이고 / 삽입, 삭제 작업이 많고 / 특정 위치 데이터를 조회하는 경우가 별로 없다면 List
- 인덱스를 이용해서 데이터를 가져오는 것이 빈번하다면 ArrayList 
- 데이터의 추가/삭제가 빈번하다면 LinkedList 

### * 추가 참고 자료
- [Java 심화] List 컬렉션에서 참조변수의 타입을 어떤 것으로 해야할까? (https://wonit.tistory.com/249)

### * 출처
- https://bb-dochi.tistory.com/9
- https://mong9data.tistory.com/132
- https://zorba91.tistory.com/287
- https://devlog-wjdrbs96.tistory.com/64
- https://shlee0882.tistory.com/95
