이번 글에서는 MySQL의 스토리지 엔진 가운데 가장 많이 사용되는 InnoDB 스토리지 엔진을 살펴보려 한다.

![image](https://user-images.githubusercontent.com/55661631/150125318-addca592-eed1-4c55-9477-8485335df8fa.png)

위 그림은 InnoDB의 아키텍처를 아주 간단히 보여준다. 각 부분에 관한 자세한 설명은 주요 특징드롸 함께 살펴보자.

# InnoDB 스토리지 엔진의 특성

## 프라이머리 키에 의한 클러스터링

 InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 이로 인해 프라이머리 키에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다.

결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정(쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높음)된다.

## 외래 키 지원

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨이서 지원하는 기능으로 MyISAM이나 MEMORY테이블에서는 사용할 수 없다.

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 주의하는 것이 좋다.

## MVCC(Multi Version Concurrency Control)

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다. InnoDB는 언두 로그를 이용해 이 기능을 구현한다.

이해를 위해 격리 수준이 READ_COMMITED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 살펴보겠다.

```sql
INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
```

INSERT 문이 실행되면 아래와 같이 INSERT 한 레코드가 디스크 영역뿐만 아니라 버퍼 풀에도 생성된다. 

![image](https://user-images.githubusercontent.com/55661631/150125349-1b9e3919-3be2-4d8a-b5e1-d5c804407b72.png)

```sql
UPDATE member SET m_area = '경기' WHERE m_id=12;
```

![image](https://user-images.githubusercontent.com/55661631/150125371-17fd91f7-d89e-42ec-9160-c582a1ca6614.png)

UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이, InnoDB의 버퍼 풀은 새로운 값인 `경기`로 수정된다. 그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드(백그라운드 스레드)에 의해 새로운 값으로 수정돼 있을 수도 있고 아닐 수도 있다.

아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회하면 어떻게 될까?

```sql
SELECT * FROM member WHERE m_id = 12;
```

이 질문의 답은 트랜잭션 격리 수준에 따라 다르다.

- READ UNCOMMITED
    - InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환한다.
- READ COMMITED 또는 그 이상
    - InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.

이러한 과정을 DBMS에서 MVCC라고 표현한다. 즉, 하나의 레코드에 대해 2개의 버전이 유지되고, 상황에 따라 어느 데이터가 보여지는지 달라지는 구조다. 

여기서는 한 개의 데이터만 가지고 설명했지만 트랜잭션이 길어지면 관리해야 하는 예전 버전의 데이터가 무한히 많아질 수 있다. 이 경우에 MySQL 서버가 느려지거나 문제가 발생할 수 있기 때문에, 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 완료하는 것이 좋다.

## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

![image](https://user-images.githubusercontent.com/55661631/150125403-51ca173a-a2f4-4ef1-84ff-d76f573beaef.png)

InnoDB에서 격리 수준이 SERIALIZABLE 이 아닌 경우 INSERT 와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

아래 그림에서 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다. 이를 **잠금 없는 일관된 읽기**라고 표현하며, InnoDB에서는 변경되기 전의 데이터를 읽기 위해 **언두(Undo) 로그를 사용**한다.

## 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다. 

InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어 데드락 감지 스레드가 주기적으로 잠금 대기 목록 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 하나를 강제 종료한다. 이때 어느 트랜잭션을 종료할 것인지를 판단하는 기준은 언두 로그 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다. 그 이유는 언두 래코드를 적게 가졌다는 의미는 롤백을 해도 언두 처리를 해야 할 내용이 적다는 것을 의미하기 때문이다(서버 부하를 더 유발한다).

## 자동화된 장애 복구

InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재돼 있다. 그러한 메커니즘을 이용해 MySQL 서버가 시작될 때, 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지(Partial write) 등에 대한 일련의 복구 작업이 자동으로 진행된다.

# 언두 로그

InnoDB 스토리지 엔진은  트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업하는데, 이 백업된 데이터를 언두 로그라고 한다.

트랜잭션을 설명하는 글에서 언두 로그가 어떻게 사용되는지 자세히 설명했으니, 이번에는 간단히 살펴보자.

- 트랜잭션 보장
    - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.
- 격리 수준 보장
    - 특정 트랜잭션에서 데이터를 변경하는 도중에 다른 트랜잭션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어 반환하기도 한다.

# 리두 로그 및 로그 버퍼

리두 로그(Redo Log)는 InnoDB에서 두 가지 역할을 한다.

- MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안정장치 역할. 트랜잭션 4가지 요소인 ACID 중에 D(Durable, 영속성)에 해당한다.
    - 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 서버가 종료되기 직전의 상태로 복구한다.
- 데이터 파일에 쓰는 비용을 낮추는 역할
    - 데이터 파일을 변경 작업은 랜덤하게 디스크에 기록해야 하기 때문에 상대적으로 큰 비용이 필요하다. 이러한 부하를 줄이기 위해 데이터의 DBMS에는 변경된 데이터를 기록하기 위한 리두 로그와 리두 로그를 버퍼링할 수 있는 로그 버퍼, 데이터 파일과 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀을 사용한다.

![image](https://user-images.githubusercontent.com/55661631/150125454-fdd3a0c7-f08c-4316-9e29-8dd3023a5427.png)

# InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분이며, 다음과 같은 역할을 한다.

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 역할
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할

일반적인 애플리케이션에서는 INSERT나 UPDATE 그리고 DELETE와 같이 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하게 되면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

## 버퍼 풀 구조

InnoDB 스토리지 엔진은 대량의 읽기 요청을 효율적으로 처리하기 위해, 버퍼 풀이라는 거대한 메모리 공간을 페이지 단위로 나누어 관리하며, 버퍼 풀 페이지를 효율적으로 관리하기 위해 크게 3개의 자료 구조로 관리한다. 

- LRU(Least Recently Used) 리스트
- 플러시(Flush) 리스트
- 프리(Free) 리스트

### LRU 리스트

![image](https://user-images.githubusercontent.com/55661631/150125500-bd41a3c8-9fe0-4146-a985-96e789b0a373.png)

LRU 리스트 위 그림과 같은 구조를 띠고 있는데, 엄밀하게 LRU와 MRU(Most Recently Used) 리스트가 결합된 형태라고 보면 된다(**MRU = New 서브리스트, LRU = Old 서브리스트**).

LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다.

InnoDB 스토리지 엔진에서 데이터를 찾는 과정은 대략 다음과 같다.

1. 필요한 레코드가 저장된 데이터 페이지 버퍼 풀에 있는지 검사
2. 디스크에 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인트를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
4. 버퍼 풀의 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여되며, 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼 풀에서 제거된다.
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가한다. 

**정리**

처음 한 번 읽힌 데이터 페이지가 자주 사용된다면 그 데이터 페이지는 InnoDB 버퍼 풀의 MRU 영역에서 계속 살아남게 되고, 반대로 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU의 끝으로 밀려나 결국은 버퍼 풀에서 제거된다.

### 플러시 리스트

InnoDB는 데이터가 변경되면 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에 변경 내용을 반영한다. 변경된 시점에 바로 변경된 데이터를 디스크에 동기화하지 않기 때문에 동기화되지 않은 데이터 페이지가 존재하는데 이를 **더티 페이지**라고 한다. 이와 반대로 디스크에서 읽은 상태로 전혀 변경되지 않은 데이터 페이지는 **클린 페이지**라고 한다.

플러시 리스트는 더티 페이지의 변경 시점 기준의 페이지 목록을 관리한다. 정리하면, 디스크에서 읽은 상태에서 변경이 없다면 플러시 리스트에 관리되지 않고 한 번이라도 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점에 디스크에 기록된다.

### 프리 리스트

프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.

## 버퍼 풀 플러시(Buffer Pool Flush)

InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상에 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플로시 기능을 백그라운드로 실행한다.

- 플러시 리스트(Flush_list) 플러시
    - InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그를 비워야 한다. 그러나 이때 오래된 리두 공간이 지워지려면 반드시 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화돼야 한다. 이를 위해 InnoDB 스토리지 엔진은 주기적으로 프롤시 리스트 플로시 함수를 호출해서 동기화 작업을 수행한다.
- LRU 리스트(LRU_list) 플러시
    - InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 공간을 만들어야 하는데, 이를 위해 LRU 리스트 플러시 함수가 사용된다.
    InnoDB 스토리지 엔진은 LRU 리스트의 끝부분부터 시작해서 설정된 개수만큼의 페이지들을 스캔하면서 더티 페이지가 발견되면 디스크에 동기화 시키고, 클린 페이지는 프리(Free) 리스트로 옮긴다.

# 참고

- [https://ssup2.github.io/theory_analysis/MySQL_Buffer_Pool_Redo_Log_Log_Buffer/](https://ssup2.github.io/theory_analysis/MySQL_Buffer_Pool_Redo_Log_Log_Buffer/)
- [https://myinfrabox.tistory.com/49](https://myinfrabox.tistory.com/49)
- [https://velog.io/@jsj3282/4.-InnoDB-스토리지-엔진-아키텍처#2-innodb-버퍼-풀](https://velog.io/@jsj3282/4.-InnoDB-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98#2-innodb-%EB%B2%84%ED%8D%BC-%ED%92%80)
- [https://velog.io/@pk3669/Mysql-Redo-Undo-Log](https://velog.io/@pk3669/Mysql-Redo-Undo-Log)
- [https://flashsql.github.io/innodb-doc-kr/blog/innodb/5.1.buffer-pool.html](https://flashsql.github.io/innodb-doc-kr/blog/innodb/5.1.buffer-pool.html)
