이번 글에서는 MySQL의 스토리지 엔진 가운데 가장 많이 사용되는 InnoDB 스토리지 엔진을 살펴보려 한다.

![image](https://user-images.githubusercontent.com/55661631/150125318-addca592-eed1-4c55-9477-8485335df8fa.png)

위 그림은 InnoDB의 아키텍처를 아주 간단히 보여준다. 각 부분에 관한 자세한 설명은 주요 특징드롸 함께 살펴보자.

# InnoDB 스토리지 엔진의 특성

## 프라이머리 키에 의한 클러스터링

 InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 이로 인해 프라이머리 키에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다.

결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정(쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높음)된다.

## 외래 키 지원

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨이서 지원하는 기능으로 MyISAM이나 MEMORY테이블에서는 사용할 수 없다.

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 주의하는 것이 좋다.

## MVCC(Multi Version Concurrency Control)

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다. InnoDB는 언두 로그를 이용해 이 기능을 구현한다.

이해를 위해 격리 수준이 READ_COMMITED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 살펴보겠다.

```sql
INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
```

INSERT 문이 실행되면 아래와 같이 INSERT 한 레코드가 디스크 영역뿐만 아니라 버퍼 풀에도 생성된다. 

![image](https://user-images.githubusercontent.com/55661631/150125349-1b9e3919-3be2-4d8a-b5e1-d5c804407b72.png)

```sql
UPDATE member SET m_area = '경기' WHERE m_id=12;
```

![image](https://user-images.githubusercontent.com/55661631/150125371-17fd91f7-d89e-42ec-9160-c582a1ca6614.png)

UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이, InnoDB의 버퍼 풀은 새로운 값인 `경기`로 수정된다. 그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드(백그라운드 스레드)에 의해 새로운 값으로 수정돼 있을 수도 있고 아닐 수도 있다.

아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회하면 어떻게 될까?

```sql
SELECT * FROM member WHERE m_id = 12;
```

이 질문의 답은 트랜잭션 격리 수준에 따라 다르다.

- READ UNCOMMITED
    - InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환한다.
- READ COMMITED 또는 그 이상
    - InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.

이러한 과정을 DBMS에서 MVCC라고 표현한다. 즉, 하나의 레코드에 대해 2개의 버전이 유지되고, 상황에 따라 어느 데이터가 보여지는지 달라지는 구조다. 

여기서는 한 개의 데이터만 가지고 설명했지만 트랜잭션이 길어지면 관리해야 하는 예전 버전의 데이터가 무한히 많아질 수 있다. 이 경우에 MySQL 서버가 느려지거나 문제가 발생할 수 있기 때문에, 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 완료하는 것이 좋다.

## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

![image](https://user-images.githubusercontent.com/55661631/150125403-51ca173a-a2f4-4ef1-84ff-d76f573beaef.png)

InnoDB에서 격리 수준이 SERIALIZABLE 이 아닌 경우 INSERT 와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

아래 그림에서 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다. 이를 **잠금 없는 일관된 읽기**라고 표현하며, InnoDB에서는 변경되기 전의 데이터를 읽기 위해 **언두(Undo) 로그를 사용**한다.

## 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다. 

InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어 데드락 감지 스레드가 주기적으로 잠금 대기 목록 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 하나를 강제 종료한다. 이때 어느 트랜잭션을 종료할 것인지를 판단하는 기준은 언두 로그 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다. 그 이유는 언두 래코드를 적게 가졌다는 의미는 롤백을 해도 언두 처리를 해야 할 내용이 적다는 것을 의미하기 때문이다(서버 부하를 더 유발한다).

## 자동화된 장애 복구

InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재돼 있다. 그러한 메커니즘을 이용해 MySQL 서버가 시작될 때, 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지(Partial write) 등에 대한 일련의 복구 작업이 자동으로 진행된다.

# 언두 로그

InnoDB 스토리지 엔진은  트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업하는데, 이 백업된 데이터를 언두 로그라고 한다.

트랜잭션을 설명하는 글에서 언두 로그가 어떻게 사용되는지 자세히 설명했으니, 이번에는 간단히 살펴보자.

- 트랜잭션 보장
    - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.
- 격리 수준 보장
    - 특정 트랜잭션에서 데이터를 변경하는 도중에 다른 트랜잭션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어 반환하기도 한다.

# 리두 로그 및 로그 버퍼

리두 로그(Redo Log)는 InnoDB에서 두 가지 역할을 한다.

- MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안정장치 역할. 트랜잭션 4가지 요소인 ACID 중에 D(Durable, 영속성)에 해당한다.
    - 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 서버가 종료되기 직전의 상태로 복구한다.
- 데이터 파일에 쓰는 비용을 낮추는 역할
    - 데이터 파일을 변경 작업은 랜덤하게 디스크에 기록해야 하기 때문에 상대적으로 큰 비용이 필요하다. 이러한 부하를 줄이기 위해 데이터의 DBMS에는 변경된 데이터를 기록하기 위한 리두 로그와 리두 로그를 버퍼링할 수 있는 로그 버퍼, 데이터 파일과 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀을 사용한다.

![image](https://user-images.githubusercontent.com/55661631/150125454-fdd3a0c7-f08c-4316-9e29-8dd3023a5427.png)

# InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분이며, 다음과 같은 역할을 한다.

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 역할
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할

일반적인 애플리케이션에서는 INSERT나 UPDATE 그리고 DELETE와 같이 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하게 되면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

## 버퍼 풀 구조

InnoDB 스토리지 엔진은 대량의 읽기 요청을 효율적으로 처리하기 위해, 버퍼 풀이라는 거대한 메모리 공간을 페이지 단위로 나누어 관리하며, 버퍼 풀 페이지를 효율적으로 관리하기 위해 크게 3개의 자료 구조로 관리한다. 

- LRU(Least Recently Used) 리스트
- 플러시(Flush) 리스트
- 프리(Free) 리스트

### LRU 리스트

![image](https://user-images.githubusercontent.com/55661631/150125500-bd41a3c8-9fe0-4146-a985-96e789b0a373.png)

LRU 리스트 위 그림과 같은 구조를 띠고 있는데, 엄밀하게 LRU와 MRU(Most Recently Used) 리스트가 결합된 형태라고 보면 된다(**MRU = New 서브리스트, LRU = Old 서브리스트**).

LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다.

InnoDB 스토리지 엔진에서 데이터를 찾는 과정은 대략 다음과 같다.

1. 필요한 레코드가 저장된 데이터 페이지 버퍼 풀에 있는지 검사
2. 디스크에 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인트를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
4. 버퍼 풀의 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여되며, 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼 풀에서 제거된다.
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가한다. 

**정리**

처음 한 번 읽힌 데이터 페이지가 자주 사용된다면 그 데이터 페이지는 InnoDB 버퍼 풀의 MRU 영역에서 계속 살아남게 되고, 반대로 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU의 끝으로 밀려나 결국은 버퍼 풀에서 제거된다.

### 플러시 리스트

InnoDB는 데이터가 변경되면 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에 변경 내용을 반영한다. 변경된 시점에 바로 변경된 데이터를 디스크에 동기화하지 않기 때문에 동기화되지 않은 데이터 페이지가 존재하는데 이를 **더티 페이지**라고 한다. 이와 반대로 디스크에서 읽은 상태로 전혀 변경되지 않은 데이터 페이지는 **클린 페이지**라고 한다.

플러시 리스트는 더티 페이지의 변경 시점 기준의 페이지 목록을 관리한다. 정리하면, 디스크에서 읽은 상태에서 변경이 없다면 플러시 리스트에 관리되지 않고 한 번이라도 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점에 디스크에 기록된다.

### 프리 리스트

프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.

## 버퍼 풀 플러시(Buffer Pool Flush)

InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상에 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플로시 기능을 백그라운드로 실행한다.

- 플러시 리스트(Flush_list) 플러시
    - InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그를 비워야 한다. 그러나 이때 오래된 리두 공간이 지워지려면 반드시 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화돼야 한다. 이를 위해 InnoDB 스토리지 엔진은 주기적으로 프롤시 리스트 플로시 함수를 호출해서 동기화 작업을 수행한다.
- LRU 리스트(LRU_list) 플러시
    - InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 공간을 만들어야 하는데, 이를 위해 LRU 리스트 플러시 함수가 사용된다.
    InnoDB 스토리지 엔진은 LRU 리스트의 끝부분부터 시작해서 설정된 개수만큼의 페이지들을 스캔하면서 더티 페이지가 발견되면 디스크에 동기화 시키고, 클린 페이지는 프리(Free) 리스트로 옮긴다.

# Double Write Buffer

**InnoDB** 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 이로 인해 InnoDB의 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러시할 때 페이지중 일부만 디스크 파일에 기록되는 문제가 발생해 그 페이지의 내용을 복구 할 수 없을 수도 있다.

이렇게 페이지가 일부만 기록되는 현상을 **파셜 페이지(Partial-page)** 또는 **톤 페이지(Torn-page)**라고 한다. 이 현상은 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있다.

InnoDB 스토리지 엔진에서는 이와 같은 문제를 막기 위해 Double-Write 기법을 이용한다. Double-Write 기법이 작동하는 방식을 간단한 예시와 함께 살펴보자.

![image](https://user-images.githubusercontent.com/55661631/151166645-5b2bb057-54de-4609-8b46-f73aca8f6cc8.png)

‘A’ ~ ‘D’까지의 더티 페이지를 디스크로 플러시한다고 가정해보자.

1. InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 위해 ‘A’ ~ ‘D’까지의 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 Double Write Buffer에 기록한다.
2. InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.
3. 이렇게 Double Write Buffer 공긴에 기록된 변경 내용은 실제 데이터 파일에 ‘A’ ~ ‘D’ 더티 페이지가 정상적으로 기록되면 더이상 필요가 없어진다.
4. 만약, 실제 데이터 파일의 쓰기가 중간에 실패할 경우(비정상적인 종료) InnoDB 스토리지 엔진은 재시작될 때 항상 Double Write Buffer의 내용과 데이터 파일들을 비교해서 다른 내용을 담고 있는 페이지가 있으면 복사한다.

 Double Write Buffer는 데이터의 안정성을 위한 기능이다. 그러나 비용이 큰 작업이기 때문에 데이터의 무결성이 매우 중요한 서비스에서 Double Write Buffer의 활성화를 고려 하는 것이 좋다.

# 체인지 버퍼

RDBMS에서 레코드가 INSERT되거나 UPDATE될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다. 그런데 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하기 때문에 테이블의 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다.

그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있다면 바로 업데이트를 수행하지만 그렇지 않으면 이를 즉시 실행하지 않고 임시 공간에 저장 해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 된다. 이때 사용하는 임시 메모리 공간을 **체인지 버퍼(Change Buffer)**라고 한다. 단, 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 **유니크 인덱스는 체인지 버퍼를 사용할 수 없다.**

체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 **체인지 버퍼 머지 스레드**라고 한다.

# 어댑티브 해시 인덱스

InnoDB 스토리지 엔진의 대포적인 인덱스는 B-Tree이다. B-Tree 인덱스에서 특정 값을 찾는 과정은 매우 빠르게 처리된다. 그러나 빠르냐 느리냐의 기준은 상대적인 것이며, 데이터베이스 서버가 얼마나 많은 일을 하느냐에 따라 B-Tree 인덱스에서 값을 찾는 과정이 느려질 수도 있고 빨라질 수도 있다.

**쉽게 말하자면, 자주 사용되는 데이터 탐색에도 매번 B-Tree의 경로를 찾는 과정은 비효율적이기 때문에 자연스럽게 쿼리의 성능이 떨어질 수 밖에 없다.**

어댑티브 해시 인덱스는 이러한 B-Tree 검색 시간을 줄여주기 위해 도입된 기능이며, InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.

InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다. 결국 B-Tree를 루트 노드부터 리프 노드까지 찾아가는 비용이 없어지고 그만큼 CPU는 적은 일을 하지만 쿼리의 성능이 빨라지게 된다.

![image](https://user-images.githubusercontent.com/55661631/151166684-5f050fd8-b565-4cf8-b456-41a4994ea32b.png)

참고로 해시 인덱스는 다음과 같은 방식으로 Key와 Value가 결정된다.

- Key
    - B-Tree 인덱스의 고유번호
        - 어댑티브 해시 인덱스는 하나만 존재하지만 B-Tree 인덱스는 여러 개가 존재하기 때문에 어느 B-Tree 인덱스인지 속한 것인지 구분하기 위해 사용된다.
    - B-Tree 인덱스의 실제 키 값
- Value
    - 데이터 페이지 주소
        - 실제 키 값이 저장된 데이터 페이지 메모리 주소를 의미한다(InnoDB 버퍼 풀에 로딩된 페이지의 주소).

어댑티브 해시 인덱스가 보여줄 수 있는 성능 효과를 그래프로 살펴보자.

![image](https://user-images.githubusercontent.com/55661631/151166721-b4f541a7-f3dc-447a-a3e8-bcd26fb9c91f.png)

여기까지만 보면 어댑티브 해시 인덱스가 정말 좋아 보이지만, 어댑티브 해시 인덱스가 성능 향상에 크게 도움이 되지 않는 경우도 있다.

- **어댑티브 해시 인덱스가 성능 향상에 도움되지 않는 경우**
    - 디스크 읽기가 많은 경우
    - 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
    - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

- **어댑티브 해시 인덱스가 성능 향상에 도움되는 경우**
    - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
    - 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
    - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

- **어댑티브 해시 인덱스를 사용할 때 주의할 점**
    - 저장 공간인 메모리를 사용하며, 때로는 상댕히 큰 메모리 공간을 사용할 수 있다.
    - 어댑티브 해시 인덱스가 활성화되면 InnoDB 스토리지 엔진은 그 키 값이 해시 인덱스에 있든 없든 검색해야 한다. 즉, 해시 인덱스의 효율이 없는 경우에도 InnoDB는 계속 해시 인덱스를 사용한다.
    - 어떤 테이블의 인덱스가 어댑티브 해시 인덱스에 적재돼 있다고 할 때, 이 테이블을 삭제하거나 변경하면 InnoDB스토리지 엔진은 이 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야 한다. 이로 인해 상당히 많은 CPU 자원을 사용하고, 그만큼 데이터베이스 성능이 느려진다.

# InnoDB와 MyISAM 스토리지 엔진 비교

### MyISAM

- 장점
    - 엔진 자체가 아주 기본적인 기능만 제공하여 상당히 가볍다.
    - **검색(SELECT)작업이 상당히 빠르다.**
    - 검색하고자 하는 내용에 대한 복합검색이 가능하다.
- 단점
    - 트랜잭션을 지원하지 않는다. 따라서 트랜잭션 처리하고자 한다면, 개발자가 코드 레벨에서 처리해야 한다.
    - 쓰기 작업 시 테이블 잠금이 걸리기 때문에 속도가 느리다.
    - 데이터 무결성에 대한 보장이 되지 않는다.
    - 외래키의 생성이 불가능하다.
    

### InnoDB

- 장점
    - 데이터 무결성을 보장해준다.
    - 트랜잭션 기능을 제공한다.
    - 장애복구, 외래 키 등 다양한 기능을 제공한다.
    - 레코드 단위로 잠금이 걸려서 MyISAM보다 데이터 수정 작업에 유리하다.
- 단점
    - 많은 기능을 제공하다 보니 작업 속도가 상대적으로 느리다.
    - 시스템 자원을 많이 사용한다.

![image](https://user-images.githubusercontent.com/55661631/151166761-a9d6c894-7789-48f2-be0e-9f61d98ccf8a.png)

<aside>
💡 **참고**
MySQL 8.0 이전에는 전문 검색이나 공간 좌표 검색 기능은 MyISAM 테이블에서만 지원됐다. 그러나 MySQL 8.0부터 모든 시스템 테이블이 InnoDB 스토리지 엔진으로 교체됐고, 방금 말한 기능들은 InnoDB 스토리지 엔진을 지원하도록 개선됐다.

</aside>

# 참고

- [https://ssup2.github.io/theory_analysis/MySQL_Buffer_Pool_Redo_Log_Log_Buffer/](https://ssup2.github.io/theory_analysis/MySQL_Buffer_Pool_Redo_Log_Log_Buffer/)
- [https://myinfrabox.tistory.com/49](https://myinfrabox.tistory.com/49)
- [https://velog.io/@jsj3282/4.-InnoDB-스토리지-엔진-아키텍처#2-innodb-버퍼-풀](https://velog.io/@jsj3282/4.-InnoDB-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98#2-innodb-%EB%B2%84%ED%8D%BC-%ED%92%80)
- [https://velog.io/@pk3669/Mysql-Redo-Undo-Log](https://velog.io/@pk3669/Mysql-Redo-Undo-Log)
- [https://flashsql.github.io/innodb-doc-kr/blog/innodb/5.1.buffer-pool.html](https://flashsql.github.io/innodb-doc-kr/blog/innodb/5.1.buffer-pool.html)
- [https://tech.kakao.com/2016/04/07/innodb-adaptive-hash-index/](https://tech.kakao.com/2016/04/07/innodb-adaptive-hash-index/)
- [https://sarc.io/index.php/mariadb/1140-innodb-adaptive-hash-index](https://sarc.io/index.php/mariadb/1140-innodb-adaptive-hash-index)

# 예상 면접 질문 및 답변

### Q. MVCC란?

MVCC는 언두 로그를 이용해 잠금을 사용하지 않는 일관된 읽기를 제공하는 기술이다. 여기서 잠금을 사용하지 않는 일관된 읽기는 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않으면, 이 변경은 다른 사용자의 SELECT 작업에 반영되지 않는 것을 말한다.

### Q. 언두 로그란?

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업하는데, 이 백업된 데이터를 언두 로그라고 한다.

언두 로그는 트랜잭션이 롤백될 때 변경 전 데이터로 복구하기 위해 사용되고, 특정 트랜잭션에서 데이터를 변경하는 도중에 다른 트랜잭션에서 데이터를 조회하면 격리 수준에 맞게 변경 전의 데이터를 보여주기 위해 사용된다.

### Q. InnoDB 버퍼 풀이란?

InnoDB 스토리지 엔진에서 가장 핵심적인 부분이며, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 역할과 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할을 수행한다.

### Q. 리두 로그란?

### Q. Double Write Buffer란?

### Q. InnoDB에서 어댑티브 해시 인덱스는 어떤 역할을 하는가?

### Q. InnoDB와 MyISAM 스토리지 엔진의 차이점은?

본문 참고
