# Deadlock이란?

**교착 상태**

프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태

두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태

*→ 다중 프로그래밍 환경에서 흔히 발생하는 문제*

# 교착 상태의 조건

## 왜 발생하는가

![https://camo.githubusercontent.com/a78df4477534741d6058a959e753fe82050589944c8801b4fc88c23d4696fcad/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323433453839333535373134433236453238](https://camo.githubusercontent.com/a78df4477534741d6058a959e753fe82050589944c8801b4fc88c23d4696fcad/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323433453839333535373134433236453238)

Process 1과 Process 2 각각 Resource 1과 Resource 2가 둘 다 필요한 상황

→ Process 1은 Resource 1을 먼저 요청하여 얻고, Process 2는 Resource 2를 먼저 요청하여 얻

→ 이후 Process 1은 Resource 2를 요청하지만 이미 Process 2가 사용중이여서 wait 상태가 되며, Process 2는 Resource 1을 요청하지만 이미 Process 1이 사용중이므로 wait 상태가 된다

→ Process 1과 Process 2 모두 무한정 wait 상태가 되어 빠져나오지 못한다

## 발생 조건

교착 상태가 발생하려면 4가지 조건이 모두 성립되어야 한다

1. **상호 배제 (Mutual Exclusion)**
2. **점유 대기 (Hold and Wait)**
3. **비선점 (No Preemption)**
4. **순환 대기 (Circular Wait)**

### 상호 배제 (Mutual Exclusion)

자원(resource)은 한번에 한 프로세스만 사용할 수 있다

**공유 불가능한 자원**의 동시 사용을 피하기 위해 사용되는 **알고리즘** 사용

**공유 불가능한 자원이란 무엇인가**

동시에 실행되고 있는 프로그램 간의 통신에 사용되는 비트 단위의 깃발, 계수기, 큐, 등

Stack 영역을 제외한 부분은 스레드끼리 공유하는데, 스레드가 언제라도 정지되거나 시작될 수 있으며, 이 때 의도치 않는 데이터가 있거나 변경될 수 있다

**상호 배제는 어디서 구현하는가**

임계 구역(critical section)으로 불리는 코드 영역에서 구현한다

![](https://t1.daumcdn.net/cfile/tistory/2125F33F583A924F10)

화장실이라는 공유자원을 안전하게 관리하고 싶다. Mutex가 지켜주는 덕에, 화장실은 한번에 한명만 사용할 수 있다

프로세스는 임계 구역에 진입하기 위해 진입 허가를 요청하는데, 이러한 요청을 구현하는 부분이 입장 구역(entry section)이다. 입장 구역에서 기다리다가 진입 허가가 나면 임계 구역이 진입한 후 빠져나올 때에는 퇴장 구역(exit section)이 있다. 이를 제외한 다른 코드 부분들은 나머지 구역(remainder section)이라 한다

```jsx
do {
	wait(mutex);  // 입장 구역
	// 임계 구역
	signal(mutex);  // 퇴장 구역
	// 나머지 구역
}
```

*임계 구역 문제 : 임계 구역으로 지정되어야 할 코드 영역이 임계 구역으로 지정되지 않았을 때 발생할 수 있는 문제*  


**뮤텍스(Mutex)와 세마포어(Semaphore)**

뮤텍스와 세마포어 모두 상호 배제 조건을 달성하기 위해 고안된 기법이며, 위 알고리즘을 구현할 때 사용한다

*임계 구역을 한 명 씩만 사용할 수 있는 화장실로 표현해보자. 여러명이 화장실을 가고 싶어할 때 어떻게 처리할까?*

- **뮤텍스**
    - 화장실 예시
        - 화장실이 하나이고, 이를 이용하기 위해 열쇠가 필요한 경우
        - 화장실을 가고싶은데 열쇠가 있으면 아무도 화장실에 없다는 뜻이고, 그렇기 때문에 사용할 수 있다
        - 화장실을 가고싶은데 열쇠가 없으면 누군가 화장실을 사용하고 있다는 뜻이고, 그렇기 때문에 사용할 수 없다
        - 다른 사람들이 와도 열쇠가 없으면 줄을 서야하고, 열쇠가 생기면 차례대로 화장실을 사용한다
        
        → 스레드/프로세스에 의해 공유될 수 있는 열쇠라는 object를 통해 상호 배제를 달성한다
        
    - Lock & Unlock
        - Lock : 임계 구역에 들어갈 권한을 얻음
        - Unlock : 임계 구역을 모두 사용했음을 알림
- **세마포어**
    - 화장실 예시
        - 화장실이 여러개 있고, 빈 칸 개수를 확인할 수 있다
        - 화장실을 가고싶으면 빈 칸 개수를 확인하고 1개 이상이면 사용한다
        - 화장실을 가고싶은데 빈 칸 개수가 0개이면 1개 이상이 될 때 까지 대기한다
        
        → 공통으로 관리하는 하나의 값(integer value)을 통해 상호 배제를 달성한다
        
    - 세마포어 P, V 연산
        - S : 자원의 개수
        - P : 임계 구역에 들어가기 전에 수행하는 연산
        → 프로세스의 진입 여부 결정
        - V : 임계 구역에서 나올 때 수행하는 연산
        → 자원 반남 알림, 대기 중인 프로세스 신호
        
        ```python
        procedure P(S)
        	while S == 0:  # S가 0이면 1이 될 때 까지 대기
        		wait
        	S = S - 1  # 자원을 할당 받으면 다른 프로세스에게 할당되지 못하도록 함
        end P
        
        # 임계 구역
        
        procedure V(S)
        	S = S + 1  # 자원 반납
        end V
        ```
        

![](https://mblogthumb-phinf.pstatic.net/MjAxODA5MTlfNjAg/MDAxNTM3MzMwNjc2MDM2.9CPjSC-tEBHzj1BJK_sytNBOu7SyW46FEwvUPtswhE4g.jbXKCxIasAt_eBgUyF1lTR3yUvMlV4mtWtVNaLN26Qsg.PNG.qbxlvnf11/20180919_131738.png?type=w800)

- 이외에도 **Monitor**를 통해 상호 배제를 구현할 수 있다

**알고리즘**

임계 구역에서 상호 배제를 보장하는 알고리즘은 여러가지 있다

- **데커의 알고리즘**
flag와 turn 변수를 통해 프로세스 중 누가 임계영역에 진입할 것인지와 다음 차례가 누구인지 나타낸다
- **피터슨의 알고리즘**
데커의 알고리즘과 유사하나, 다른 프로세스/스레드에게 **진입 기회를 양보**한다
- **다익스트라의 알고리즘**
- **램퍼드의 베이커리 알고리즘**
여러개의 프로세스/스레드에 대한 처리가 가능하며, 가장 작은 수의 **번호표**(프로세스에 부여된 고유한 번호이자 우선순위)를 가지고 있는 프로세스가 임계역역에 진입한다

**참고 : [https://yoongrammer.tistory.com/61](https://yoongrammer.tistory.com/61)*

이러한 소프트웨어적 솔루션의 경우 여러가지 **단점**이 존재한다

- 속도가 느리다
- 구현이 복잡하다
- Busy waiting이 발생하여 비효율적이다
계속 무한 루프를 돌면서 최대한 다른 스레드에게 CPU를 양보하지 않는다
- 프로세스 실행 중 선점 될 경우, overhead가 발생한다

### 점유 대기 (Hold and Wait)

최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 한다
*나 하나 있는데, 너 꺼 갖고 싶어*

### 비선점 (No Preemption)

다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없다

Nonpreemptive Scheduling을 통해 구현하는데, 이 때 프로세스는 자원을 스스로 반납할 때 까지 계속 자원을 사용할 수 있다

### 순환 대기 (Circular Wait)

프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다

![https://4.bp.blogspot.com/-APk6FsJscLc/XKhtCmOUwrI/AAAAAAAAAtY/Ud4EohrB4JoKn3aBzbM_pYQmOzi8OX05gCLcBGAs/s1600/deadlock-prevention.jpg](https://4.bp.blogspot.com/-APk6FsJscLc/XKhtCmOUwrI/AAAAAAAAAtY/Ud4EohrB4JoKn3aBzbM_pYQmOzi8OX05gCLcBGAs/s1600/deadlock-prevention.jpg)

→ 하나라도 성립하지 않게 한다면 교착 상태 해결이 가능하다

→ 순환 대기 조건의 경우, 점유 대기 조건과 비선점 조건을 만족해야 성립해야 하는 조건이다. 즉, 4가지 조건이 서로 완전히 독립적인 것은 아니다.

# 교착 상태의 관리

현재까지 교착 상태를 완벽하게 막는 것은 불가능하다

여러 운영 체제들은 제각기 다른 방식들로 교착 상태에 대한 대응법을 제시하고 있으며, 이는 앞선 교착상태의 4가지 조건들 중 하나에 대응하는 방식으로 작동한다

## 예방(Prevention)

교착 상태 발생 조건 중 하나를 제거하여 발생하기 전에 예방한다

1. **상호 배제 부정**
여러 프로세스가 공유 자원을 사용하도록 한다
2. **점유 대기 부정**
한 프로세스가 수행되기 전에 모든 자원을 할당시키고, 자원이 점유되지 않을 때에만 다른 프로세스에서 요구할 수 있도록 한다
→ 자원 과다 사용으로 인한 효율성 문제
→ 프로세스가 요구하는 자원을 파악하는 데에 대한 비용
→ 자원에 대한 내용을 저장 및 복원하기 위한 비용
→ 기아 상태
→ 무한 대기 문제
3. **비선점 부정**
자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원을 반납하도록 한다
4. **순환 대기 부정**
자원에 고유 번호를 할당하여 순서대로 자원을 요구하도록 한다

**단점**

- 자원 낭비가 심하다
- 비용이 많이 든다

## 회피(Avoidance)

교착 상태가 발생하면 탐지 후 회피해서 해결한다

자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하여 순환 대기가 발생하지 않도록 자원 할당 상태를 검사한다

그렇다면 순환 대기가 발생할지 안할지 어떻게 판별할까?

**안전 상태와 불안전 상태**

운영체제는 교착 상태에 빠질 수 있는 가능성이 있는 불안전 상태(unsafe state)와 그렇지 않은 안전 상태(safe state)로 상태를 나눈다
이에 따라 프로세스가 자원을 요청할 때, **안전 상태를 유지할 수 있는 요청만 수락**하고 **불안전 상태를 초래하는 요청은 거절**한다

![https://mblogthumb-phinf.pstatic.net/20150604_245/three_letter_1433413942804Uvuw5_JPEG/7_06_StateSpaces.jpg?type=w2](https://mblogthumb-phinf.pstatic.net/20150604_245/three_letter_1433413942804Uvuw5_JPEG/7_06_StateSpaces.jpg?type=w2)

- **안전 상태**(Safe State)
시스템이 교착 상태를 일으키지 않으면서 각 프로세스가 요구한 최대량만큼 필요한 자원을 할당해 줄 수 있는 상태로, 안전 순서열(safe sequence)이 존재하는 상태
    - 안전 순서열 → 현재 상태에서 모든 프로세스에게 결국에는 자원을 할당할 수 있게 해주는 프로세스 실행 순서
- **불안전 상태**(Unsafe State)
안전 순서열이 존재하지 않는 상태로, 교착 상태이기 위한  필요조건
*교착 상태 → 불안전 상태 (역은 성립 X)*

![https://media.vlpt.us/images/seorim0801/post/05d3359e-de16-4487-ae36-b766dd0ca2c8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-07-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.29.39.png](https://media.vlpt.us/images/seorim0801/post/05d3359e-de16-4487-ae36-b766dd0ca2c8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-07-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.29.39.png)

프로세스가 자원을 요청했을 때, 할당 이후 안전 상태가 유지 되는지 예측 이후 할당 여부를 결정하게 된다

회피 알고리즘 2가지에 대해 각각 사용하는 **자료구조**, **구현 방법**, **교착 상태 예측 방법**, **알고리즘의 구현**, 그리고 **단점**을 알아보자

**1. 자원 할당 그래프 알고리즘 (Resource-Allocation Graph Algorithm)**

→ 각 자원 유형의 단위 자원이 하나밖에 없는 경우

이 알고리즘은 자원 할당 그래프를 통해 **교착 상태를 탐지하고 회피**하고자 한다

**사용 자료구조**

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrfhTr%2FbtqEOaRIRIF%2FPf7sJGboKDTWhvnkFDKxH0%2Fimg.png)

- **요청 간선(Request Edge)** : 프로세스 노드 → 자원 노드 실선
프로세스가 자원을 할당 받고 싶다고 요청
- **할당 간선(Assignment Edge)** : 자원 노드 → 프로세스 노드 실선
자원은 프로세스에 할당
- **요청 가능 간선(Claim Edge)** : 프로세스 노드 → 자원 노드 점선
향후에 프로세스가 자원을 요청할 수 있음

**교착 상태 예측 방법**

1. 그래프에 사이클이 존재하는지 확인
2. 사이클이 존재할 경우, 자원 유형에 몇 개의 사례가 있는지 확인
3. 하나의 사례만 있으면 **교착 상태**, 여러 사례가 있으면 **교착 상태 가능성**이 있다고 판별

→ 사이클이 존재할 때 자원 유형이 하나 ↔ 교착 상태, 자원 유형이 한 개 이상 ← 교착 상태

**알고리즘의 구현**

1. 프로세스가 자원 요청
2. 요청 간선 추가
3. 요청 간선을 할당 간선으로 변환
4. 교착 상태 예측 후 불안전 상태일 경우 대기, 안전 상태일 경우 요청 승인

**자원 할당 그래프 알고리즘의 단점**

- 자원 요청 시, 탐지 알고리즘을 실행시키기 때문에 그에 대한 Overhead가 발생한다
→ 성능에 큰 영향

**2. 은행원 알고리즘 (Banker's Algorithm)**

→ 각 자원 유형의 단위 자원이 여러 개일 경우

운영 체제가 최소 하나의 프로세스에게는 자원을 줄 수 있는 상태를 항상 유지하도록 한다
*은행이 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야 한다는 개념에서 나왔다*

**사용 자료구조**

은행원 알고리즘이 수행되기 위해서는 다음 자료구조들 필요하다

- [Available] 시스템은 현재 얼만큼의 자원을 보유하고 있는가
길이가 m인 벡터로 표현하며, Available[j] = k 일 경우 자원 j를 k개 사용할 수 있다
- [MAX] 각 프로세스는 최대 얼만큼의 자원을 요청할 수 있는가
n * m 행렬로 표현하며, Max[i, j] = k 일 경우 프로세스 i는 자원 j를 최대 k개까지 요청할 수 있다
- [Allocation] 각 프로세스는 현재 얼만큼의 자원을 보유하고 있는가
n * m 행렬로 표현하며, Allocation[i, j] = k 일 경우 프로세스 i는 자원 j를 k개 할당받았다
- [Need] 각 프로세스에 남아 있는 자원 요구량이 얼마인가
n * m 행렬로 표현하며, Need[i, j] = k 일 경우 프로세스 i는 작업을 완료하기 위해 자원 j가 k개 더 필요하다
Need의 경우, Max - Allocation을 통해 계산할 수 있다

**교착 상태 예측 방법**

안전 상태인지 조사, 즉 **안전 순서열 탐지**는 다음과 같은 작업을 통해 이루어진다

```python
# 안전 알고리즘 (Safety Algorithm)
Work = Available
Finish = False * i

find i where Finish[i] == False and Need[i] <= Work[i]
if i exists:  # 자원을 할당받을 수 있는 프로세스를 찾음
	Work[i] = Work[i] + Allocation[i]
	Finish[i] = True
	find next i
else:
	if all(Finish) == True:  # 모든 프로세스가 자원을 할당받을 수 있음
		safe_state
	else:
		unsafe_state
```

**알고리즘의 구현**

프로세스가 **자원을 요청**할 경우 다음과 같은 작업이 이루어진다

```python
# 자원 요청 알고리즘 (Resource Request Algorithm)
if Request[i][j] < Need[i][j]:
	if Request[i][j] <= Available[j]:
		# 요청된 자원 할당
		Avaiable[j] = Available[j] - Request[j]
		Allocation[i][j] = Allocation[i][j] + Request[i][j]
		Need[i][j] = Need[i][j] - Request[i][j]
		
		if safe_state:  # 안전 상태인지 조사
			# 할당 완료
		else:
			rollback  # 데이터 구조는 이전 상태로 복구
			wait  # 대기
	else:
		wait  # 현재 자원이 부족하기 때문에 대기한다
else:
	error  # 프로세스가 최대 요청치 초과
```

**은행 알고리즘의 단점**

- 할당할 수 있는 자원의 수가 일정해야 한다
- 사용자 수가 일정해야 한다
- 항상 불안전 상태를 방지해야 하기 때문에 자원 이용도가 낮다
- 최대 자원 요구량(Max)를 미리 알아야 한다
- 프로세스들은 유한한 시간 안에 자원을 반납해야 한다

이러한 단점들 때문에 은행원 알고리즘은 굉장히 복잡하며 실제 상황에 접목시키기 어려우며, 따라서 현재 사용하는 방식은 아니다

## 탐지(Detection)

교착 상태가 발생한 후, 회복을 하기 위해서는 우선 탐지를 해야한다
*탐지 알고리즘 → 회복 알고리즘*

탐지 알고리즘 2가지에 대해 알아보자

**1. 대기 그래프 (Wait-for Graph)**

→ 각 자원 유형의 단위 자원이 하나밖에 없는 경우

앞서 봤던 자원 할당 그래프의 변형으로, 자원 할당 그래프에서 자원 노드를 제거하고 프로세스 간의 간선으로 나타낸 그래프이다

![(a) 자원 할당 그래프에 대응하는 (b) 대기 그래프](https://mblogthumb-phinf.pstatic.net/20150605_82/three_letter_1433482259847QyuM0_JPEG/7_09_TwoGraphs.jpg?type=w2)

(a) 자원 할당 그래프에 대응하는 (b) 대기 그래프

- Pi → Rq, Rq → Pj 간선 2개 : Pi → Pj 간선
    
    → 프로세스 j가 보유중인 자원을 프로세스 i가 기다린다는 의미이다
    

**2. Shoshani & Coffman 알고리즘**

→ 각 자원 유형의 단위 자원이 여러 개일 경우

앞서 봤던 **은행원 알고리즘**에서 사용하는 자료구조 Available, Allocation, Request를 사용한다

```python
# 탐지 알고리즘 (Detection Algorithm)
Work = Available
**if Allocation[i] != 0:
	Finish[i] = False
else:
	Finish[i] = True**

find i where Finish[i] == False and **Request[i]** <= Work[i]
if i exists:
	Work[i] = Work[i] + Allocation[i]
	Finish[i] = True
	find next i
else:
	if all(Finish) == True:
		**not Deadlock**
	else:
		**Deadlock**
```

## 회복(Recovery)

교착 상태가 발생한 후, 교착 상태를 일으킨 프로세스를 탐지하여 종료하거나 할당된 자원을 해제 시켜 회복시킨다

**1. 프로세스 종료 방법 (Process Termination)**

교착 상태의 프로세스를 종료시켜 자원을 회수한다

- 전체 종료 : 교착 상태의 프로세스를 모두 중지
- **부분 종료** : 교착 상태가 제거될 때 까지 하나씩 프로세스 중지

**2. 자원 선점 방법 (Resource Preemption)**

교착 상태 사이클이 없어질 때 까지 자원을 빼앗아 다른 프로세스에게 제공한다

## 무시

위 기법을 사용할 경우 성능에 큰 영향을 미칠 수 있기 때문에, 교착 상태 발생 확률이 낮은 경우에는 별다른 조치를 취하지 않는다

교착 상태는 자주 발생하지 않으므로 이 방법이 가장 비용이 적게 들며, 대부분의 운영체제에서 채택된 방식이다

# 비고

## 결론

### 데드락이란 무엇인가

데드락은 교착 상태라고도 불리며, 프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태를 뜻합니다. 흔히 다중 프로그래밍에서 발생하는 문제로, 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태가 됩니다.

### 데드락이 발생하는 조건은 무엇인가

데드락이 발생하기 위해서는 조건 상호 배제, 점유 대기, 비선점, 그리고 순환 대기. 총 4가지 조건이 만족되어야 하며, 하나라도 만족되지 못하면 교착 상태가 발생하지 않습니다.

상호 배제는 자원은 한번에 한 프로세스만 사용할 수 있다는 조건,
점유 대기는 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다리고 있다는 조건,
비선점은 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없다는 조건,
순환 대기는 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다는 조건입니다

### 데드락을 해결할 수 있는 방법에는 어떤 것이 있는가

- 예방
    - 교착 상태의 4가지 조건 부정
- 회피
    - 자원 할당 그래프 알고리즘
    - 은행원 알고리즘
- 탐지
    - 대기 그래프
    - Shoshani & Coffman 알고리즘
- 회복
    - 프로세스 종료법
    - 자원 선점법

### 은행원 알고리즘을 설명해보아라

은행원 알고리즘이란 다중 프로그래밍 환경에서 교착 상태가 발생했을 때 해결하는 회피 알고리즘 중 하나입니다. 은행원 알고리즘은 프로세스가 자원을 요청했을 때, 자원을 주게 된다면 교착 상태가 발생할 수 있는 상태가 되는지 예측한 후, 그렇지 않은 경우에만 요청에 응하는 방식으로 교착 상태를 회피합니다.

따라서 프로세스가 자원을 요청하는 자원 요청 알고리즘과 해당 요청을 응했을 때 교착 상태가 발생할 수 있는 상태가 되는지, 즉, 안전 상태가 유지되는지 판별하는 안전 알고리즘을 이용하여 은행원 알고리즘을 구현할 수 있습니다.

### 은행원 알고리즘의 문제(단점)는 무엇인가

- 할당할 수 있는 자원의 수가 일정해야 한다
- 사용자 수가 일정해야 한다
- 항상 불안전 상태를 방지해야 하기 때문에 자원 이용도가 낮다
- 최대 자원 요구량(Max)를 미리 알아야 한다
- 프로세스들은 유한한 시간 안에 자원을 반납해야 한다

결국 은행원 알고리즘은 구현이 복잡하고, 프로세스의 최대 자원 요구량을 미리 알아야한다는 점에서 실질적으로 사용하기에는 어렵습니다

## 출처

- [Deadlock](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/DeadLock.md)
- [위키백과 교착 상태](https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C)
- [뮤텍스(Mutex)와 세마포어(Semaphore)의 차이](https://worthpreading.tistory.com/90)
- [상호배제 방법 - 뮤텍스, 세마포어, 모니터](https://m.blog.naver.com/qbxlvnf11/221362041286)
- [세마포어(Semaphore) & 뮤텍스(Mutex)](https://gyoogle.dev/blog/computer-science/operating-system/Semaphore%20&%20Mutex.html)
- [[OS] 은행원 알고리즘 (예시문제 까지)](https://hoyeonkim795.github.io/posts/bankers/)
- [교착상태 회피, 은행원 알고리즘](https://3catpapa.tistory.com/103)
- [은행원 알고리즘?](https://velog.io/@seorim0801/%EC%9D%80%ED%96%89%EC%9B%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
- [[운영체제]교착상태 회피-은행원 알고리즘(Banker's Algorithm) 쉬운 예시, 안전상태, 불안전상태](https://jhnyang.tistory.com/102)
- [[운영체제]데드락을 회피할 수 있는 자원할당 그래프, 은행원 알고리즘](https://wannabe-gosu.tistory.com/26)
- [[운영체제] 7장 교착상태 (Deadlocks)](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=three_letter&logNo=220380867227)
