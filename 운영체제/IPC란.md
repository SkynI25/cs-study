## 1. IPC가 필요한 이유 
우리가 사용하는 프로세스들은 모두 유저공간(user-mode)에서 각각 OS로부터 할당받은 독립된 공간에서 실행되어있습니다. 
여기서 말하는 **'독립되어 있다'** 는 것은 다른 프로세스의 영향을 받지 않는다는 장점이 있지만, 독립되어 있는 만큼 별도의 설비가 없이는 서로간에 통신이 어렵다는 문제 역시 발생합니다.
하지만 우리는 하나의 프로그램을 실행하더라도 여러 Process끼리 협력이 필요한 상황이 있습니다. <br> 예를 들어 특정 Task를 여러개의 sub task로 나누어 더 빠르게 수행을 해야 한다거나, 동시에 많은 task를 한번에 처리해야 하는 경우가 있을 것입니다.
이를 해결하고자 커널 영역(kernel-mode)에서 IPC(Inter-Process Communication)라는 프로세스들 간에 통신을 제공하고 있습니다. 
<br>
`` IPC = Inter-Process Communication ``
즉, IPC는 프로세스들 사이에 서로 데이터를 주고 받는 행위를 말합니다. IPC는 크게 두가지 모델로 나뉩니다.

## 2. IPC 모델:  Shared memory

![공유메모리모델](https://user-images.githubusercontent.com/48278519/142004523-2aa268d4-c20a-4e0d-8b8c-e6059c635e12.png)
### 1) 공유 메모리 모델 특징 
- 두 개 이상의 프로세스들이 주소 공간의 일부를 공유하며, 공유한 메모리 영역에 읽기/쓰기를 통해서 통신을 수행합니다. **(Read and Write)** 
- 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해 주게되고, 이후 어떤 프로세스건 해당 메모리영역에 접근 할 수 있습니다. 
공유 메모리가 설정되면, 그 이후의 통신은 커널의 관여 없이 진행 가능합니다.

### 2) 공유 메모리 모델의 장점
- 커널의 관여 없이 메모리를 직접 사용하여 **IPC 속도가 빠릅니다.** (다시말해, 커널메모리영역에서 관리하기에 빠르게 접근 가능)
- 프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능합니다.

### 3) 공유 메모리 모델의 단점
 -  메시지 전달 방식이 아니기에 데이터를 읽어야하는 시점을 알 수 없다. 
 -  예를 들어, 프로세스 A가 공유 메모리에 데이터 전달해도 프로세스 B가 그것을 알 수 없습니다. 
 -  그렇기 때문에 별도의**동기화 기술이 필요합니다.**
 - 동시에 같은 메모리 위치를 접근하는 문제가 발생할 수 있습니다. (공유메모리에 접근할 프로세스들 간의 락 메커니즘이 필요합니다.)

### 4) 예시 
- POSIX : Prtable OS Interface (for UNIX)
- 공유 메모리(Shared Memory)

## 3. IPC 모델:  메세지 전달(Message passing)
![메세지전달](https://user-images.githubusercontent.com/48278519/142008124-97236b8d-e928-459c-b1f0-d3e2c947d003.JPG)

### 1) 메세지 전달 모델 특징 
- 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 협력하는 프로세스들 사이에 메시지 형태로 정보를 **Send/Receive** 하는 방법입니다.
- 커널을 경유하여  메시지를 송/수신자끼리 주고 받으며, 커널에서는 데이터를 버퍼링합니다. 
- 예를 들어, A 프로세스가 커널로 메세지를 보내면, 커널이 B에게 메세지를 보내주는 방식입니다.
- 프로세스간 메모리 공유 없이 동작이 가능합니다.

### 2) 메세지 전달 모델 장점
- 커널에서 데이터의 주고받음을 컨트롤할 수 있어 별도의 **동기화 로직이 없어도 됩니다.**

### 3) 메세지 전달 모델 단점
- 커널을 통해서 데이터 주고받기 때문에 **shared memory 모델보다 느립니다.**

### 4) 메세지 전달 모델의 종류 
 **Direct Communication : 통신하려는 프로세스의 이름을 명시적으로 표시하여 메시지를 직접 전달하는 방식**
 ![직접통신](https://user-images.githubusercontent.com/48278519/142185465-86fc75c4-a492-4f96-9740-35e68980859d.png)
- 예를 들어 A 프로세스가 B 프로세스에게 메시지를 전달하고 싶을 때, 커널에게 직접적으로 수신자 A 프로세스가 메시지를 전달한 후, 커널이 B 프로세스에게 해당 메시지를 전달하는 방식
- 프로세스 간 링크는 유일합니다.
- 대부분 양방향으로 구성됩니다.


 **Indirect Communication : mailbox(또는 port)를 통해 메시지 간접 전달하는 방식**
![간접통신](https://user-images.githubusercontent.com/48278519/142185473-2bdeb004-402c-4ad1-abf0-f76970ffae13.png)
- port로 전송만 하면 되기 때문에 복잡한 communication link를 만들 수 있으며, 다 : 다 관계가 가능합니다.
- 예를 들어 A 프로세스가 B 프로세스에게 메시지를 전달 하고 싶을 때, 커널 내부 특정 포트에 메시지를 저장해놓고, B 프로세스가 해당 포트에 접근하여 메시지를 전달받는 방식입니다.


### 5) 메세지 전달 모델 예시1 : 파이프
![파이프](https://user-images.githubusercontent.com/48278519/142011419-87b696f1-dd29-4a85-8dae-5ba7680dd700.png)
 <br> 
 #### * 특징 *
 -  두 개의 프로세스를 파이프로 연결하여, 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 하며 데이터를 통신합니다.
 - 1:1 통신이면서 한쪽 방향으로만 데이터가 이동합니다(Half-duplex). 
 - 주로 **부모-자식간의 단방향 통신**으로 사용됩니다.
 - 용량 제한이 있기 때문에 파이프가 가득 차면 더 이상 쓸 수 없습니다.
-  한쪽 프로세스는 단지 읽기만하고 다른 프로세스는 단지 쓰기만 하는 단순한 데이터 흐름에 적합합니다.
 <br> 
 
### 6) 메세지 전달 모델 예시2 : 메세지 큐 
![메세지큐](https://user-images.githubusercontent.com/48278519/142183844-583c6a17-f9c2-43e9-923c-96a84007447c.JPG)
#### * 특징 *
- FIFO 자료구조를 가지는 큐를 이용하여 데이터를 전송 및 수신하는 방식입니다.
- 위의 파이프가 스트림 기반으로 동작한다면, 메세지 큐는 메세지(또는 패킷) 단위로 동작합니다.
- 부모/자식 관계가 아니더라도, **어느 프로세스간의 데이터 송수신이 가능하다**는 장점이 있습니다.
- 양방향 통신이 가능하며, 메시지의 형태는 사용자가 정의하여 사용할 수 있습니다. 
- Message Queue에 쓸 데이터에 번호를 붙힘으로써 다수의 프로세스가 동시에 데이터를 쉽게 다룰 수 있습니다.
- 비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리 할 수 있습니다.
- 데이터가 많이 쌓일수록 추가적인 메모리 자원이 필요하며, 큐에 데이터를 넣고 나오는 과정에서 오버헤드가 발생 할 수 있습니다.

 <br> 
 
### 7) 메세지 전달 모델 예시3 : 소켓
![소켓](https://user-images.githubusercontent.com/48278519/142187112-a78307ac-b5c8-47f9-97c3-722dbd354850.png)
![소켓통신방식](https://user-images.githubusercontent.com/48278519/142194437-74a47f18-8ec6-4405-a5c8-1e06695b2286.png)
 socket() : 소켓 생성
 bind() : 주소 할당
 listen() : 통신 요청을 기다림
 connect() : 통신 요청
 accept() : 통신 수락
 read() / write() : 통신
close() : 소켓 종료

#### * 소켓 *
- socket은 네트워크 상에서 통신하기 위한 종단점으로 추상화된 개념입니다.
- 소켓 통신은 흔히 네트워크 통신 기법으로 많이 사용되는 방법으로, 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고받는 방식입니다. 
- 소켓이 네트워크 기능을 담고 있다보니 네트워크 기능을 이용해 IPC로도 사용할 수 있게 됩니다. 즉, 소켓을 한 pc 내 두개의 프로세스 간 통신 기법으로도 사용이 가능합니다. 
( 기존의 네트워크 상에서 소켓 통신과 달라지는 점은 sock_addr_in 구조체를 sock_addr_un으로 변경해주고 속성을 AF_INET을 AF_UNIX로 변경해주고 소켓 통신을 하기 위한 파일 경로가 필요하다고 합니다.)

#### * 특징 *
- 네트워크 소켓을 이용하여 Client - Server 구조로 데이터 통신을 하며, 원격에서 프로세스간 데이터를 공유 할 때 사용합니다.
- 프로세스는 포트 번호를 이용하여 통신하려는 상대 프로세스의 소켓을 찾아갑니다.
- 포트의 도움으로, 다른 IPC와 달리 프로세스의 위치에 독립적이며, machine boundary와 관계가 없기 때문에 Local 또는 Remote로 사용할 수 있다는 특징이 있습니다. (다른 IPC는 모두 Local에서만 사용할 수 있습니다.)
- 서버단에서는 bind, listen, accept 진행해 소켓 연결을 위한 준비를 하고, 클라이언트 단에서는 connect을 통해 서버에 요청하고 연결이 수립 된 후에서는 socket에 send 함으로써 데이터를 주고 받습니다.
- 범용적인 IPC로써 양방향 통신이 가능합니다.
- 패킷 단위로 주고 받음으로 직관적으로 이해하기 쉬운 코드를 만들 수 있습니다.
- 하지만 Internet UDP와는 달리 경로를 지정할 수 없습니다. 


## 4. 정리 및 면접 질문 대비

#### IPC란 무엇인가요?
- IPC는 프로세스들 사이에 서로 데이터를 주고 받는 방식, 즉 프로세스 간의 통신을 의미합니다. 각 프로세스는 독립적인 실행 객체이기 대문에 프로세스간 통신을 하려면 커널이 제공하는 IPC 모델 방식을 사용해서 통신을 해야 합니다. 

#### IPC의 예시를 들어보세요
- IPC는 크게 두가지 모델로 나눌 수 있습니다. 첫째는  주소 공간의 일부를 공유하며 공유한 메모리 영역에 읽기/쓰기를 통해 통신하는 '공유 메모리'모델이 있으며, 공유 메모리 모델의 예시론 공유 메모리와 POSIX가 있습니다.
두 번째로는 메세지 전송 모델입니다. 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 송수신자 간에 전송/수신을 통해 통신하는 방식입니다. 예시로는 파이프, 메모리큐,소켓 등이 있습니다.

#### 위에서 말한 두 모델의 장단점을 설명해 보세요
- 공유 메모리 모델의 경우, 커널의 관여 없이 메모리를 직접 사용하여 통신하기 때문에 통신 속도가 빠른 장점이 있지만, 별도의 동기화 과정이 필요하며 동시에 메모리 위치를 접근하는 문제가 발생할 수 있다는 단점이 있습니다. 따라서 별도의 접근 제어 방법이 필요하며, 접근 제어 방식은 locking이나 세마포어(semaphore) 등이 있습니다.
- 메세지 전달 모델의 경우, 커널을 통해서 데이터를 주고받기 때문에 통신 속도가 느리다는 단점이 있지만, 커널에서 데이터를 주고받음을 컨트롤할수 있어 안전하며 send/receive연산에 대해선 커널이 동기화를 제공해준다는 장점이 있습니다.

### 출처
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kbh3983&logNo=220788898350
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=bycho211&logNo=220985701140
https://velog.io/@jhlee508/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Message-Queue-IPC
https://apphappy.tistory.com/118
https://yoongrammer.tistory.com/56
https://www.byfuls.com/programming/read?id=63
