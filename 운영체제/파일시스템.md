## 1. 관련 용어

### 1) File
- 컴퓨터에서 의미가 있는 정보를 담은 논리적인 단위
- 비휘발성 보조기억장치(하드디스크)에 저장
- 운영체제는 다양한 저장 장치를 file 이라는 동일한 논리적 단위로 볼 수 있게 해줌
- 실행 파일과 데이터 파일로 존재 

  * **실행 파일** : 운영체제가 메모리로 가져와 CPU를 이용하여 작업하는 파일 (ex 윈도우 exe 파일. 유닉스는 따로 확장자 없음)
  * **데이터 파일** : 실행파일이 작업하는데 필요한 데이터를 모아놓은 파일

### 2) File attribute (= metadata)
- 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들
- 파일 이름, 유형, 저장된 위치, 접근 권한, 소유자 등

### 3) Directory
- 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한파일
- 자신의 디렉토리에 속한 파일 이름 및 메타데이터 정보를 담음


## 2. File System
### 1) 정의 

- 컴퓨터에서 파일이나 자료를 쉽게 발견 할 수 있도록, 유지, 관리하는 방법.

- 파일 및 메타데이터, 디렉토리 정보 등을 관리

- 디스크가 하나의 집이라면 파일 시스템은 여기에는 화장실을 두고, 여기에는 침실을 두는 것 같이 그 집을 관리하는 방법을 말합니다.

### 2) 특징

- 사용자 영역이 아닌 커널 영역에서 동작

- 파일을 빠르게 읽기, 쓰기, 삭제 등 기본적인 기능을 원활히 수행하기 위한 목적

- 계층적 디렉터리 구조를 가짐 

- 디스크 파티션 별로 하나씩 둠


### 3) 파일 시스템 개발 목적

- 파일 관리 용이

- HDD의 막대한 용량을 효율적으로 이용

- HDD와 메인 메모리 속도차 줄이기 : HDD에 저장된 데이터들은 HDD에서 실행되는 것이 아니라 메인 메모리에 Load 되어 사용된다. 이 때 파일 시스템이 HDD에 저장된 데이터들의 목차가 되어 데이터를 실행하려고 클릭 했을 때 메인 메모리에 빠르게 load 될 수 있도록 한다.


### 4) 파일 시스템의 역할

- 불의의 사태를 대비하여 파일의 예비(Backup)와 복구(Recovery) 등의 기능을 제공한다.

- 사용자가 파일을 편리하게 사용할 수 있도록 파일의 논리적 상태(디렉터리)를 보여주어야 한다.

- 파일을 안전하게 사용할 수 있도록 하고, 파일이 보호되어야 한다.

- 파일의 정보가 손실되지 않도록 데이터 무결성을 유지해야 한다.


### 5) 주요 파일 시스템

- **Windows** : FAT(FAT12/16/32,exFAT), NTFS

- **Linux** : ext(ext2/3/4) 

- **Mac OS** : APFS, HFS, HFS+

- **Google** : GFS(Google File System으로 구글에서 사용하는 분산 파일 시스템)


### 6) 파일 시스템 구조

- UNIX 파일 시스템에서 디스크는 512, 1024, 2048 바이트 등의 크기를 가지는 블록들로 구성되며,Boot Block, Super Block, I-Node Block, Data Block 4개의 영역을 가진다.
![1](https://user-images.githubusercontent.com/48278519/145079342-ee31059f-162a-4a49-aa42-1b957fd42665.png)


 **1) 부트 블록** :  부팅시 필요한 코드를 저장하고 있는 블록

 **2) 슈퍼 블록** : 전체 파일 시스템에 대한 정보를 저장하고 있는 블록

   - 파일 시스템의 총 블록 개수, 사용 가능한 I-node, 사용 가능한 디스크 블록 개수, 블록 크기 등

   - File 시스템마다 각각의 슈퍼블록을 가지고 있음


 **3) 데이터 블록** : 디렉터리별로 디렉터리 엔트리와 실제파일에 대한 데이터가 저장된 블록


 **4) I-node 블록** : 각 파일이나 디렉터리에 대한 모든 정보를 저장하고 있는 블록

   - 파일 소유자의 사용자 번호(UID)  및 그룹 번호(GID), 파일크기, 파일 타입, 생성 시기, 최종 변경시기, 최근 사용 시기, 파일의 보호권한, 파일 링크수, 데이터가 저장된 블록의 시작 주소 등 

- **참고 : I-Node 란?**
![3](https://user-images.githubusercontent.com/48278519/145080117-fe4bbfef-3932-4fdd-9294-8512ce72575f.png)
![2](https://user-images.githubusercontent.com/48278519/145080710-7c0b72b2-cb4e-4009-8d85-dfea1286bae1.png)

  - 파일에 대한 정보(메타 데이터)를 가지는 고정 크기를 가진 구조체(1개의 inode는 64byte로 이루어짐)

  - i-node, i-node table, i-number, addressing으로 구성

    - **i-node** : 하나의 파일/디렉토리의 모든 정보를 가진 테이블(구조체)

    - **i-node table** : 전체 i-node를 가지고 있는 테이블 (주기억장치에 저장됨)

    - **i-number** : i-node가 i-node table에 등록되는 entry number 

    - **addressing** :  블록 위치 관리(12개의 직접 데이터 블록, 1개의 간접 데이터 블록)

  예를 들어, 어떤 한 파일이나 디렉토리를 만들게 되면 1개의 inode가 만들어진다. 그  inode가 inode Table에 등록이되고, 등록되는 entry-number를 그 inode에 대한 inumber라고 한다.
  ![4](https://user-images.githubusercontent.com/48278519/145080698-e3179426-cfba-4006-acab-a64405be14bd.png)

    - **Direct Block & Indirect Block** : 기존 Direct Block만 존재했을 땐, 4KB 크기 데이터 12개만 처리 가능했음. 하지만 더 큰 크기의 데이터를 내포해야 할 필요가 발생했고, Single Indirect는 한 깊이 들어가서  Direct block을 연결한 것. 여기엔 4KB/4byte = 1024개 즉 4MB 만큼의 data를 포함할 수 있게 된다. 동일한 원리로 Double indirect는 두 깊이 들어가고 Triple indirect는 3깊이 더 깊게 연결되어 더 큰 용량의 데이터를 포함시킬 수 있다.


## 3. 파일 디스크립터(File Descriptor)


### 1) 파일 디스크립터(File Descriptor)란 
- 프로세스는 FD(file descriptor)를 통해 파일에 접근한다.

- **시스템으로부터 할당 받은 파일을 대표하는 0이 아닌 정수 값**

- 프로세스에서 열린 파일의 목록을 관리하는 테이블의 **인덱스**

-  프로세스가 실행 중 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다.

-  그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.

## 2) FD 할당 및 접근 과정 
![5](https://user-images.githubusercontent.com/48278519/145081689-ef7aa899-62a7-42a5-a304-4133b022c734.png)

 **1) File Descriptor Table**

  - 프로세스가 현재 사용중인 파일을 관리하기 위한 테이블, 프로세스마다 한 개씩 가짐

  - File Table을 가리키는 포인터를 담고있는 배열, 이 배열의 index가 fd


 **2) (Open) File Table**

  - 프로세스에 의해 open된 파일의 읽기/쓰기 동작을 지원하기 위한 테이블. 파일이 열릴 때마다 하나씩 할당
  <br> *ex) 만약 하나의 프로세스가 A라는 파일을 3번 open한다면, A의 File Table Entry가 3개 생성된다.

  - 테이블 Entry 안에는 open_flag, file_offset, ref_cnt, VFS table 포인터 등이 존재 

  - 파일 테이블로의 포인터를 이용하여 FD를 통해 시스템의 파일을 참조 할 수 있다.


  **3) i-node Table (i-node Table)**

  - 프로세스들이 사용하고 있는 파일의 i-node를 담고 있는 테이블
 
  - File Table과는 달리 하나의 프로세스가 A라는 파일을 3번 open해도 i-node Table Entry는 하나만 할당됨
  
  - i-node 안에는 i-node 번호, 파일 종류와 권한, 크기, 데이터 블록을 가리키는 포인터 등의 파일 정보가 들어있고, i-node Table Entry에는 i-node, ref_cnt값이 존재


 **4) 예시**
 <br>
```fd = open("fileA", O_WRONLY); 실행 ```
<br>
1. 커널은 File System에서 fileA를 찾아, 해당 파일의 i-node를 가져와 VFS i-node table의 빈 공간(Entry)에 할당. 만약 fileA의 i-node가 이미 할당되어있는 경우, ref_cnt(reference counter)만 하나 증가시킴

2. i-node 정보에 담겨있는 접근 권한을 찾아, 쓰기 권한(O_WRONLY)을 허용하는지 확인

3. 권한이 있다면 file table의 Entry에 open_flag, file_offset, ref_cnt, VFS i-node table entry 포인터 등의 정보를 할당

4. File descriptor table을 index 0부터 탐색해서, 빈 공간에 file table entry를 가리키는 포인터를 저장한다.

5. 저장한 곳의 index를 반환

6. 이후 한번 open한 데이터는 FD 통해서 접근

7. FD 사용이 끝나면 ref_cnt-- => ref_cnt == 0 이면 file table entry 삭제

8. file table entry 삭제 -> VFS inode 엔트리에 참조 카운트 값 감소 => 참조 카운트 값이 0이면(해당 파일 정보에 접근 중인 프로세스 수 == 0이면) VFS inode table entry 삭제

### 3) FCB
- **파일을 관리하기 위한 metadata를 보관하는 파일제어 블록**
- 보조기억장치에 존재하다가 파일이 오픈되면 주기억장치로 이동- 파일시스템이 관리하며 사용자가 직접 참조 불가
- 파일마다 독립적으로 가지며 시스템마다 다른 내용을 가짐
- 파일 허가, 소유, 크기, 자료 블록의 위치 등을 포함하여 자세한 파일 정보를 가지고 있음. UFS에선 inode라고 함. 
- 파일 디스크립터의 정보 
  - 파일 이름 및 파일 크기
  - 보조기억장치에서의 파일 위치
  - 파일 구조 : 순차 파일, 색인 순차 파일, 색인 파일 등
  - 보조기억장치의 유형 : 자기 디스크, 자기 테이프 등
  - 액세스 제어 정보
  - 파일 유형 : 텍스트 파일, 목적 프로그램 파일(2진 파일, 기계어 파일, 실행 파일)
  - 생성 날짜와 시간, 제거 날짜와 시간
  - 최종 수정 날짜 및 시간
  - 액세스한 횟수 : 파일 사용 횟수
  
``` 
파일 시스템은 어떠한 파티션이 있을때 해당 파티션을 부팅하기 위한 boot control block과 그 파티션에 대한 정보를 담고 있는 partition control block 을 가진다. 
그리고 파일들을 관리하기 위해 앞에서 언급하였던 디렉토리 구조를 가지고 파일마다 File Control Block을 가진다.
여기서 partition control block은 파일 시스템의 metadata, file control block은 file의 metadata라고 볼 수 있다. 일반적인 유닉스 계열의 운영체제에서는 FCB가 i-node 형태로 나타나어진다.
```
